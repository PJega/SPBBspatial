{
    "collab_server" : "",
    "contents" : "#############################################\n#INPUTS: z-vector of errors from SAR model  #\n#        W-spatial weight matrix            #\n#          This diagonal is zero,           #\n#          W must be symmetric              #\n#                                           #\n#############################################\nrequire(MASS)\nrequire(spdep)\nrequire(psych)##Trace function\n\n##START: ConfidenceIntervalSAR() to estimate MLE of rho, sigma square, conf.int for rho\nConfidenceIntervalCAR<-function(z,n=null,nrow=null,ncol=null,W=NULL){\n      #z=spatial error vector -can get it from iterative least squares method or just remove the trend\n      if(is.null(n)){\n              n=nrow*ncol\n      }else{n=n}\n      \n      if (is.null(W)){\n        #if the weight matrix is not given then the rook type weight matrix will be used\n        W=nb2mat(cell2nb(nrow,ncol,type=\"rook\"),style=\"B\")       \n      }else{\n                if(sum(W==t(W))==n*n){W=W\n                }else{\n                        stop('W is not symmetry')\n                }\n            \n        }\n      \n      I<-diag(seq(1,1,length=n))\n      \n      e.val.W=sort(Re(eigen(W)$values))\n      \n      minrho=1/e.val.W[1]+0.001\n      maxrho=1/e.val.W[n]-0.001\n      \n      \n      qud.est.eqn=function(t){\n        B=I-t*W\n        B.inv=solve(B)\n        Q=tr(B.inv%*%W)*B-n*W\n        val=t(z)%*%Q%*%z\n        return(val)\n        \n      }\n      \n      #range for rhohat (mle)\n      ranget=c(minrho,maxrho) \n      \n      #compute mle of rho\n      rhohat=uniroot(qud.est.eqn,ranget,tol=0.001)$root\n      \n      #compute mle of sigma square\n      sigma.square.mle=(t(z)%*%(I-rhohat*W)%*%z/n)[1,1] \n      \n          ##start: CDF.rho.mle()\n          CDF.rho.mle=function(r0,t,sigma.square.mle)\n          {   \n            #Covaraince matrix of z\n            sigma=function(r0)\n            {\n              val=sigma.square.mle*solve(I-r0*W)\n              return(val)   \n            }\n            \n            #Qt  matrix\n            Qt=function(t){ \n                B=I-t*W\n                B.inv=solve(B)\n                Q=tr(B.inv%*%W)*B-n*W\n                return(Q)\n            }\n            \n            #Eigenvalues of sigma.SAR%*%Qt\n            # eigenval=function(t,r0)\n            # {\n            #         sort(Re(eigen(sigma(r0)%*%Qt(t))$values))\n            # }\n            sigma.r0.val=sigma(r0)\n            Qt.val=Qt(t)\n            pro.sigma.Qt=sigma.r0.val%*%Qt.val\n            #eigen values of product of Sigma and Q determine the value of the saddlepoint\n            e.val=sort(Re(eigen(sigma.r0.val%*%Qt.val)$values))\n            \n            #To compute MGF\n            Omega=function(s,pro.sigma.Qt){\n              val=I-2*s*pro.sigma.Qt\n              return(val)\n            }\n            \n            #Moment generating function of qud.est.eqn\n            # mgf=function(Omega.val)\n            # {\n            #         1/sqrt(det(Omega.val))\n            # }\n            \n            ###Cumulant generating function of qud.est.eqn\n            kgf=function(Omega.val)\n            {\n              #log(mgf(s,t,r0))\n              val=-log(det(Omega.val))/2\n              return(val)\n              \n            }\n            \n            #First derivative of cumulant generating function\n            # kgfd1=function(s,t,r0)\n            # {\n            #         tr(solve(Omega(s,t,r0))%*%sigma(r0)%*%Qt(t))\n            #         #sum(eigenval(t,r0)/(1-2*s*eigenval(t,r0)))\n            # }\n            # \n            #Second derivative of cumulant function\n            kgfd2=function(Omega.val,pro.sigma.Qt)\n            {\n              A=solve(Omega.val)%*%pro.sigma.Qt\n              val=2*tr(A%*%A)\n              return(val)\n            }\n            \n            #Find the unique root of first derivative of cumulant function\n            # rangeshat=function(t,r0)\n            # {\n            #         c(1/(2*e.val[1])+0.00001,1/(2*e.val[n])-0.00001)\n            # }\n            # \n            # shat=function(t,r0)\n            # {\n            #         #function of s\n            #         kgfd1.t.rho<-function(s){kgfd1(s,t,r0)} \n            #         #compute the root\n            #         uniroot(kgfd1.t.rho,rangeshat(t,r0),tol=0.000001)$root\n            # }\n            \n            kgf.op=function(s,pro.sigma.Qt)\n            {\n              #log(mgf(s,t,r0))\n              val=-log(det(Omega(s,pro.sigma.Qt)))/2\n              return(val)\n              \n            }\n            sh=suppressWarnings(optimize(kgf.op,\n                                         interval=c(1/(2*e.val[1])+0.00001,1/(2*e.val[n])-0.00001),\n                                         pro.sigma.Qt=pro.sigma.Qt,tol=.001)$minimum)\n            #Define Wt function\n            Wt=function(s,kgf.val)\n            {\n              val=sign(s)*sqrt(-2*kgf.val)\n              return(val)\n            }\n            \n            #Define Ut function\n            Ut=function(s,kgf.val)\n            {\n              val=s*sqrt(kgfd2.val)\n              return(val)\n            }\n            \n            \n            \n            #sh=shat(t,r0)\n            Omega.val=Omega(sh,pro.sigma.Qt)\n            kgf.val=kgf(Omega.val)\n            kgfd2.val=kgfd2(Omega.val,pro.sigma.Qt)\n            Wt.val=Wt(sh,kgf.val)\n            Ut.val=Ut(sh,kgfd2.val)\n            \n            #saddle CDF of MLE\n            1-(pnorm(Wt.val)+dnorm(Wt.val)*((1/Wt.val)-(1/Ut.val)))\n            \n            \n          }##END: CDF.rho.mle()\n          \n      ##START: CDF.rho.mle.tval() to get the function of rho\n      CDF.rho.mle.tval=function(r0)\n      {\n        val=CDF.rho.mle(r0,rhohat,sigma.square.mle)\n        return(val)\n      }##END: CDF.rho.mle.tval()\n      \n      \n      #CDF is decreasing function in rho\n      #Inverting (Pivoting) CDF to find the confidence interval for rho\n      \n      ##START: Find.rho.lower.fun()\n      Find.rho.lower.fun=function(rhol)\n      {\n        val=abs(CDF.rho.mle.tval(rhol)-0.975)\n        return(val)\n      }##END: Find.rho.lower.fun()\n      \n      rho.lower=function(){\n        #uniroot(Find.rho.lower.fun,ranget,tol=0.001)$root\n        val=suppressWarnings(optimize(Find.rho.lower.fun,c(ranget[1],rhohat),tol=.0001)$minimum)\n        return(val)\n      }\n      \n      \n      #CDF is decreasing function in rho\n      Find.rho.upper.fun=function(rhou)\n      {\n        val=abs(CDF.rho.mle.tval(rhou)-0.025)\n        return(val)\n      }\n      \n      rho.upper=function(){\n        \n        #uniroot(Find.rho.upper.fun,ranget,tol=0.001)$root\n        val=suppressWarnings(optimize(Find.rho.upper.fun,c(rhohat,ranget[2]),tol=.0001)$minimum)\n        return(val)\n        \n      }\n      r.lower=rho.lower()\n      r.upper=rho.upper()\n      list.out=list(rhohat=rhohat,sigma.sq=sigma.square.mle,CI=c(r.lower,r.upper))\n      return(list.out)\n  #c(rhohat,sigma.square.mle,r.lower,r.upper)\n}##END: ConfidenceIntervalSAR()       \n",
    "created" : 1467950057493.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1969506375",
    "id" : "A61F2135",
    "lastKnownWriteTime" : 1446706121,
    "last_content_update" : 1446706121,
    "path" : "C:/Users/Pratheepa/Dropbox/47_MyProjectsForPhD/SPBBSpatial/R/CAR_SPBB.R",
    "project_path" : "R/CAR_SPBB.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}